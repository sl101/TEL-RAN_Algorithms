// {
// 	//  if(n = 0) return a(0) = a0 = 1;
// 	// if(n = 1) a(1) = a1 = 1;
// 	// if(n = 2) a(2) = sqrt( a(1) * a(1) + a(0) * a(0)) = sqrt(2);
// 	// if(n = 3) a(3) = sqrt( a(2) * a(2) + a(1) * a(1)) = sqrt( sqrt(2) * sqrt(2) + 1 * 1 ) = sqrt(3);
// 	// if(n = 4) a(4) = sqrt( a(3) * a(3) + a(2) * a(2)) =sqrt(sqrt(3)*sqrt(3)+sqrt(2)*sqrt(2)) = sqrt(3+2) = sqrt(5);
// }
// //    задача 2.
// //    Самый дешёвый путь
// //    В каждой клетке прямоугольной таблицы N*M записано некоторое число.
// //    Изначально игрок находится в левой верхней клетке.
// //    За один ход ему разрешается перемещаться в соседнюю клетку либо вправо, либо вниз
// //    (влево и вверх перемещаться запрещено).
// //    При проходе через клетку игрок платит определенную сумму, какое число записано в этой клетке.
// //    Требуется найти минимальную стоимость пути, отдав которую игрок может попасть в правый нижний угол.
// ===========================================================
// public static int getSequence(int num) {
// 	if (num == 0) return  1;
// 	if (num == 1) return  1;
// 	if (num % 2 == 0) {
// 			return getSequence(num / 2) + getSequence(num / 2 - 1);
// 	} else {
// 			return getSequence(num / 2) - getSequence(num / 2 - 1);
// 	}
// }
// _________

// public static int getSequenceCash(int num) {
// 	if (num == 0) return  1;
// 	if (num == 1) return  1;

// 	int cache[] = new int[num+1];

// 	if (cache[num] == 0){
// 			if (num % 2 == 0) {
// 					return getSequence(num / 2) + getSequence(num / 2 - 1);
// 			} else {
// 					return getSequence(num / 2) - getSequence(num / 2 - 1);
// 			}
// 	}
// return cache[num];
// }
//  Доработать алгоритм про самый дешевый путь (см. код в репозитории),
// чтобы помимо вычисления цены этого пути можно было его нарисовать.
